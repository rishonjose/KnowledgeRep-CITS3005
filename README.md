# KnowledgeRep-CITS3005

Knowledge graph for GitHub-like data using OWL (Owlready2), RDFLib, SHACL (pySHACL), and a Flask UI to browse and query repositories, branches, commits, issues, and pull requests.

This README covers:
- What the project does and folder layout
- Prerequisites and environment setup
- End-to-end ontology pipeline (schema → populate → validate → query)
- Running the Flask web application
- Running standalone SPARQL queries from CLI
- Running SHACL validation and viewing reports
- Optional SWRL reasoning demo
- Troubleshooting and tips


## Overview

- Ontology schema is defined programmatically in `ontology/ontology.py` and saved to `outputs/ontology.owl`.
- The populated knowledge graph is generated by `ontology/populate.py` from JSON under `data/`, producing `outputs/populated.owl`.
- SHACL shapes live in `ontology/shapes.ttl`. Validation writes a full report to `outputs/SHACL_REPORT.txt`.
- A Flask app (`run.py`) loads `outputs/populated.owl` and exposes pages to browse entities, run searches, validate SHACL, and execute custom SPARQL.

Key folders:
- `app/` — Flask application (routes, templates, static assets).
- `ontology/` — Ontology schema, population, SHACL shapes, and utility scripts.
- `data/` — Input JSON for repos, branches, commits, files, issues, pulls, users.
- `outputs/` — Generated artifacts: `ontology.owl`, `populated.owl`, `SHACL_REPORT.txt`.
- `swrl/` — Small SWRL reasoning demonstration (optional).


## Prerequisites

- Python 3.9+ recommended. Tested with a conda env on macOS.
- Install dependencies from `requirements.txt`:

```zsh
python3 -m pip install -r requirements.txt
```

If you use conda, create/activate an environment first (example):

```zsh
conda create -n knowrep python=3.9 -y
conda activate knowrep
pip install -r requirements.txt
```


## Quick start (end-to-end)

1) Generate the ontology schema (OWL):

```zsh
python3 ontology/ontology.py
```

This writes `outputs/ontology.owl`.

2) Populate the ontology from `data/` JSON:

```zsh
python3 ontology/populate.py
```

This writes `outputs/populated.owl`.

3) Run SHACL validation (optional but recommended):

```zsh
python3 ontology/validate_graph.py
```

This loads `outputs/populated.owl` and validates it against `ontology/shapes.ttl`. A detailed report is saved to `outputs/SHACL_REPORT.txt`.

4) Explore in the Flask UI:

```zsh
python3 run.py
```

Then open http://127.0.0.1:5000 in your browser. From the UI you can:
- Browse repositories, branches, commits, issues, and pull requests
- Run preset searches (user commits, concurrent contributors, merge commits, security commits)
- Run SHACL validation from the UI and view the result
- Execute a custom SPARQL query (a sample query is pre-filled)


## Running SPARQL queries from CLI

If you prefer running queries in the terminal against `outputs/populated.owl`:

```zsh
python3 ontology/run_queries.py
```

This prints a series of sample queries and results to stdout. You can adapt/extend this file with your own queries.


## SWRL reasoning demo (Incomplete)

The `swrl/ontology_swrl_demo.py` script shows a minimal SWRL-based inference (e.g., inferring `MergeCommit` where a commit has ≥2 parents). It loads the base ontology and a small sample of the dataset, runs reasoning, and writes outputs:

```zsh
python3 swrl/ontology_swrl_demo.py
```

Outputs:
- `outputs/ontology_swrl_demo.owl`
- `outputs/ontology_swrl_demo_reasoned.owl`

Note: The main population script (`ontology/populate.py`) performs practical tagging using Python logic for the larger dataset (e.g., `MergeCommit`, `InitialCommit`, `UnmergedBranch`, `ConcurrentContributor`).


## Data format

The `data/` folder contains JSON files with the following expected keys (abbreviated):
- `repos.json`: repo_id, repo_name, repo_language, repo_stars, repo_forks, repo_url (optional)
- `branches.json`: repo_id, branch_name, is_default
- `commits.json`: repo_id, branch_name, commit_sha, commit_message, commit_date (ISO8601), commit_author_login, commit_committer_login, commit_parents[]
- `files.json`: commit_sha, file_name, file_status, file_changes
- `issues.json`: repo_id, issue_id, title, state, user_login
- `pulls.json`: repo_id, pr_id, title, state, merged_at, user_login, base_branch, head_branch
- `users.json`: user_login, user_url

Population notes:
- Commits without author or committer are skipped intentionally (to satisfy ontology constraints where possible). These will be reported by SHACL if present.
- The script also computes “concurrent contributors” (users active in ≥3 repos with overlapping time windows) and tags them (`ConcurrentContributor`).
- Additional inferred tags: `MergeCommit` (≥2 parents), `InitialCommit` (no parents), `UnmergedBranch` (no `mergedInto`).


## Troubleshooting

- Command not found: `python` on macOS
	- Use `python3` instead, or activate your conda/venv and run `python`.

- Flask app cannot find `outputs/populated.owl`
	- Ensure you ran the pipeline: `python3 ontology/ontology.py` then `python3 ontology/populate.py` before starting the app.

- SHACL validation shows many violations
	- This is expected if the dataset has incomplete commits (e.g., missing author/branch/message/date). See `outputs/SHACL_REPORT.txt` for details. You can adjust the data or shapes as needed for your analysis.

- Port already in use (5000)
	- Stop other Flask instances or set a different port: `FLASK_RUN_PORT=5001 python3 run.py` (or modify `app.run()` parameters).


## Development notes

- Entry point: `run.py` (starts Flask). The app imports `app/` and loads the populated graph on startup.
- UI routes are defined in `app/routes.py`. SPARQL logic and helpers live in `app/ontology_service.py`.
- Outputs are written under `outputs/`. The code creates the folder if missing.


